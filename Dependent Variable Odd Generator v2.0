//@version=4
// MIT License

//Copyright (c) 2019 user-Noldo

//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.



study("Dependent Variable Odd Generator v2.0")

src = close 
method          = input(title="METHOD", options=["MFI", "RSI"], defval="MFI")

// MONEY FLOW INDEX (MFI)

// Money Flow Index Period

length = input(5,minval = 2)


// Essential Functions 

f_sum(_src , _length) => 

    _output  = 0.00 
    
    _length_adjusted = _length < 1 ? 1 : _length
    
    for i = 0 to _length_adjusted-1
        _output := _output + _src[i]


f_sma(_src, _length)=>
    _length_adjusted = _length < 1 ? 1 : _length
    float _sum = 0
    for _i = 0 to (_length_adjusted - 1)
        _sum := _sum + _src[_i]
    _return = _sum / _length_adjusted
   

// Unlocked Exponential Moving Average Function

f_ema(_src, _length)=>
    _length_adjusted = _length < 1 ? 1 : _length
    _multiplier = 2 / (_length_adjusted + 1)
    _return  = 0.00
    _return := na(_return[1]) ? _src : ((_src - _return[1]) * _multiplier) + _return[1]


// Function Standard Deviation

f_stdev(_src,_length) =>
    float _output = na 
    _length_adjusted = _length < 2 ? 2 : _length
    _avg  = f_ema(_src , _length_adjusted)
    evar  = (_src - _avg) * (_src - _avg)
    evar2 = ((f_sum(evar,_length_adjusted))/_length_adjusted)
    
    _output := sqrt(evar2)


// Linear Regression Channels : 

f_pearson_corr(_src1, _src2, _length) =>

    _length_adjusted = _length < 2 ? 2 : _length
    _ema1 = f_ema(_src1, _length_adjusted)
    _ema2 = f_ema(_src2, _length_adjusted)
    isum = 0.0
    for i = 0 to _length_adjusted - 1
        isum := isum + (_src1[i] - _ema1) * (_src2[i] - _ema2)
    isumsq1 = 0.0
    for i = 0 to _length_adjusted - 1
        isumsq1 := isumsq1 + pow(_src1[i] - _ema1, 2)
    isumsq2 = 0.0
    for i = 0 to _length_adjusted - 1
        isumsq2 := isumsq2 + pow(_src2[i] - _ema2, 2)
    pcc = isum/(sqrt(isumsq1*isumsq2))
    pcc



// MONEY FLOW INDEX =====> FOR BULL OR BEAR MARKET (CLOSE)


upper_s = f_sum(volume * (change(src) <= 0 ? 0 : src), length)
lower_s = f_sum(volume * (change(src) >= 0 ? 0 : src), length)

_market_index = rsi(upper_s, lower_s)


// ADDITION : DOW FACTOR 

// Dow Theory Cycles 


dow_coeff = f_pearson_corr(src,volume,length)

dow_bull_factor = (1 + dow_coeff)
dow_bear_factor = (1 - dow_coeff)


// RSI (Close)

// Function RMA 

f_rma(_src, _length) =>
    _length_adjusted = _length < 1 ? 1 : _length
    alpha = _length_adjusted
    sum = 0.0
    sum := (_src + (alpha - 1) * nz(sum[1])) / alpha


// Function Relative Strength Index (RSI)

f_rsi(_src, _length) => 

    _output = 0.00 
    _length_adjusted = _length < 0 ? 0 : _length

    u = _length_adjusted < 1 ? max(_src - _src[_length_adjusted], 0) : max(_src - _src[1] , 0) // upward change
    d = _length_adjusted < 1 ? max(_src[_length_adjusted] - _src, 0) : max(_src[1] - _src , 0) // downward change
    rs = f_rma(u, _length) / f_rma(d, _length)
    res = 100 - 100 / (1 + rs)
    res


_rsi = f_rsi(src, length)


// Switchable Method Codes 

_method = 0.00 


if (method=="MFI")

    _method:= _market_index 
    
if (method=="RSI")

    _method:= _rsi   



// Price Odds

// Conditions  

_bull_gross  = (_method)
_bear_gross  = (100 - _method )

_price_stagnant = ((_bull_gross * _bear_gross ) / 100)
_price_bull     =  (_bull_gross - _price_stagnant) 
_price_bear     =  (_bear_gross - _price_stagnant) 


_coeff_price = (_price_stagnant + _price_bull + _price_bear) / 100 


_bull     = _price_bull / _coeff_price 
_bear     = _price_bear / _coeff_price 
_stagnant = _price_stagnant / _coeff_price



// Market Types with Dow Factor

_temp_bull_gross     =  _bull     * dow_bull_factor       

_temp_bear_gross     =  _bear     * dow_bear_factor 


// Temporary Pure Odds 

_temp_stagnant = ((_temp_bull_gross * _temp_bear_gross) / 100)
_temp_bull     = _temp_bull_gross - _temp_stagnant 
_temp_bear     = _temp_bear_gross - _temp_stagnant 


// Now we ll do venn scheme (Probability Cluster)
// Pure Bull + Pure Bear + Pure Stagnant = 100 
// Markets will get their share in the Probability Cluster 

 
_coeff = (_temp_stagnant + _temp_bull + _temp_bear) / 100

_odd_bull     = _temp_bull / _coeff
_odd_bear     = _temp_bear / _coeff
_odd_stagnant = _temp_stagnant / _coeff


// Plot data

plot(_odd_bull     ,style = plot.style_histogram, color=color.green   ,linewidth=4, transp = 10)
plot(_odd_bear     ,style = plot.style_histogram, color=color.red     ,linewidth=4, transp = 20)
plot(_odd_stagnant ,style = plot.style_histogram, color=color.yellow  ,linewidth=4, transp = 30)

